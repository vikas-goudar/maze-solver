Entry/Exit points

each of the following algorithms generate perfect mazes, therefore any all can act as an entry/exit point

---

Wilson's algorithm

initialize the maze with all walls
choose a random initial cell as part of the maze
while cells not in maze
  choose a random cell not in the maze as the starting cell
  perform a random walk from the starting cell
    keep track of the path
    if a cell is revisted, remove the loop from the path 
  when a cell part of the maze is encountered add the path to the maze

The algorithm is creates trully unbiased mazes but is also inefficient

---

Binary Tree

for each cell randomly add either a "north" or a "west" passage to an adjacent cell.

The algorithm creates a maze that has a diagonal bias { since each cell exists to the right or up making it easy to go from the south-west node to the north-east node }. 
The northern and eastern boundaries will be unbroken {nodes can't point out of the maze is the northern and eastern boundaries point in only one direction } 

the reason it is called binary tree is because each node can have upto 2 children

---

Sidewinder

similar to the binary tree
at each cell can either go right and add to an 'active run' set or decide to go up {from some random cell within that run set } 
and end the 'active run' set.

This creates a maze that has a horizontal bias { we can go to right in each set and are also guaranteed an up into another set }
the northern boundary is unbroken as the only valid move is going to the right.

---

Recursive back tracker 

Select a node 
Add node to the stack {Link I}
Mark the node as being visited
Check for any unvisited neighbours of the node {Link II}
  If exists
    Set neighbour as current node
    Continue from {Link I}
  If not exists
    Pop the current node from the stack
    Set the top most node as current node 
    Continue from {link II}

---

Eller's algorithm

this algorithm processes the maze row by row

initialize the cells ofthe first row to be in their own set
randomly join adjacent cells if they are not in the same set, merge cells of both the sets in a same set {indicates that the cells are connected}
for each set, randomly create vertical connections downward to the next row, the cells that are connected share the set of the cell above them
put the remaining cells in their own sets
then again join adjacent cells ... and reapeat this process until the last row. In the last row you don't make any vertical downward connections

since the algorithm processes the maze row by row, it has a horizontal bias

---

Hunt and Kill

It goes on a random walk, and when it encounters a node that it has previously visited it stops {doesn't connect them}
then it goes row by row searching for a cell that has been unvisited and is adjacent to a visited cell
if it doesn't find on, it means that the maze has been generated
if it finds on, firstly it connects the 1 common wall with the visited cell and continues on its walk as similiar to before

creates long winding pathways

---

Recursive Division

divide the field into two halves {horizontally or vertically}
add a single passage in the wall
repeat this process recursively on either side as long as you want since each step is a vlid maze

---

Kruskal's Algorithm

we add random edges to the maze the only rule being we can't add an edge that connects two nodes of the same tree segment. and we add edges until all the nodes are visited 

---

Prim's Algorithm

choose a random node
mark it's neighbours as marked
choose of one the marked nodes and connect to an already visited node
add new neighbours to marked nodes and repeat this process until all nodes are visited

---

Growing Tree

choose some random node and add it to a set

choose a random node from the set
choose a random unvisited neighbour connect it and and add that neighbour to the set
repeat this process
if at some point we get a node that no longer has any unvisited nodes, remove it from the set
when the set becomes empty the maze is generated

the we choose the random node from the set decides the nature of the maze
using LIFO makes it like recursive backtracking
using randomized selection makes it like prims

---

Growing Binary Tree

It's the same as growing tree but instead of 1 unvisited neighbour we add 2 unvisited 2 unvisited neighbours

the point is we cann the properties of two existing algorithsm and create new mazes
