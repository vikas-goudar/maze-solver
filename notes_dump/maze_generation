Entry/Exit points

each of the following algorithms generate perfect mazes, therefore any all can act as an entry/exit point

---

Longest path

one of the ways to make the maze harder to solve is to use the longest path in the maze, however this is an np hard problem but if we consider it to be a perfect maze, we can use dijkstra 

we start the algorithm on a random node and find the node with the largest value
however we must now repeat the algorithm again from the 'largest value' node, since the inititial node could have been present in the 
middle of the longest path to the 'largest value' node
by repeating the algorithm again from the perpective of the 'largest value' node we find the node furthest from it and mark them as 
starting node and final node respectively

---

Shaping the maze

we can mask the maze to make it resemble different words, by making some nodes unvisitable
this however causes some algoriths to fail, for example binary tree and sidewinder might reach a lone boundary node where the only
possible option is to go up, but if the above node is unvisitable, our boundary node becomes cutoff from the maze

---

Aldous-Broder's algorithm
unbiased

start a random node as current node

randomly visit one of it's neighbours and set it as the current node, if it was unvisited prior make a connection between the two nodes
repeat this process until all the nodes are visited

creates an unbiased maze but is extremely slow
it starts fast but ends slow because the algorithm searches for unvisited nodes which become less and less as the algorithm progresses

---

Wilson's algorithm
unbiased 

choose a random node and mark it as visited

choose any univisited node and start a loop-erased walk { if at any point the path we are taking happens to intersect itself, remove the 
loop before continuing } until reaching a visited node
add the path to the maze, marking each of the nodes in the path as visited
repeat this process, until all the nodes are visited

creates an unbiased maze but is also slow
it start slow but ends fast because the algorithm searches for visited nodes which are less initialy but increase as the algorithm 
progresses

---

Binary Tree
biased

for each cell randomly add either a "north" or a "west" passage to an adjacent cell { don't go out of bounds }

the reason it is called binary tree is because each node can have upto 2 children

The algorithm creates a maze that has a diagonal bias { since each cell exists to the right or up making it easy to go 
from the south-west node to the north-east node but vice versa is hard }
The northern and eastern boundaries will be unbroken {nodes can't point out of the maze, therefore in the northern and eastern
boundaries the nodes has passages in the same direction } 


---

Sidewinder
biased

similar to the binary tree
at each cell can either go right and add to an 'active run' set or decide to go up {from some random cell within that run set } 
and end the 'active run' set.

This creates a maze that has a vertical bias { we can go to right in each set and are also guaranteed an up into another set }
the northern boundary is unbroken as the only valid move is going to the right.

---

Recursive back tracker 
biased

Select a node 
Add node to the stack {Link I}
Mark the node as being visited
Check for any unvisited neighbours of the node {Link II}
  If exists
    Set neighbour as current node
    Continue from {Link I}
  If not exists
    Pop the current node from the stack
    Set the top most node as current node 
    Continue from {link II}

It has a bias of creating long winding passages and little dead ends
It is similar to hunt and kill, recursive back tracker is faster because it has to visit each node only twice but less memory efficient
because it has to maintain a stack

---

Eller's algorithm

this algorithm processes the maze row by row

initialize the cells ofthe first row to be in their own set
randomly join adjacent cells if they are not in the same set, merge cells of both the sets in a same set {indicates that the cells are connected}
for each set, randomly create vertical connections downward to the next row, the cells that are connected share the set of the cell above them
put the remaining cells in their own sets
then again join adjacent cells ... and reapeat this process until the last row. In the last row you don't make any vertical downward connections

since the algorithm processes the maze row by row, it has a horizontal bias

---

Hunt and Kill
biased

set a random node as the current node

kill phase
choose a random neighbour that hasn't been visited 
set the neighbour as the current node and mark as visited
this continues until the algorithm corners itself
then start the hunt phase
scan from the top row until we encounter an unvisited node which is bordered by a visited node
make that node as the current node, connect the node to one of it's visited neibhouring nodes
and start the kill phase again 
repeat this process until there are no nodes left
creates long winding pathways

the algorithm has a bias, it creates long winding passages without much dead ends
the algortithm is similar to recursive back tracer, kill and hunt is more memory efficient since it doesn't have to maintain a stack 
but is slower becuse it has to visit each cell multiple times during the hunt phases

---

Recursive Division

divide the field into two halves {horizontally or vertically}
add a single passage in the wall
repeat this process recursively on either side as long as you want since each step is a vlid maze

---

Kruskal's Algorithm

we add random edges to the maze the only rule being we can't add an edge that connects two nodes of the same tree segment. and we add edges until all the nodes are visited 

---

Prim's Algorithm

choose a random node
mark it's neighbours as marked
choose of one the marked nodes and connect to an already visited node
add new neighbours to marked nodes and repeat this process until all nodes are visited

---

Growing Tree

choose some random node and add it to a set

choose a random node from the set
choose a random unvisited neighbour connect it and and add that neighbour to the set
repeat this process
if at some point we get a node that no longer has any unvisited nodes, remove it from the set
when the set becomes empty the maze is generated

the we choose the random node from the set decides the nature of the maze
using LIFO makes it like recursive backtracking
using randomized selection makes it like prims

---

Growing Binary Tree

It's the same as growing tree but instead of 1 unvisited neighbour we add 2 unvisited 2 unvisited neighbours

the point is we cann the properties of two existing algorithsm and create new mazes
